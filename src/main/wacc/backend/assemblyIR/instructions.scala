package wacc.assemblyIR

/**
 * A_Prog, a program in the assembly IR
 * @param data list of stored strings in the program
 * @param funcs list of functions in the program
 */
case class A_Prog(data: List[A_StoredStr], funcs: List[A_Func])

/**
 * A_SubRoutine, a subroutine in the assembly IR
 * @param lbl the label to be generated to identify the subroutine
 * @param instrs list of assembly instructions in the subroutine
 * @param data extra data to be generated by labels before the function label
 */
sealed trait A_SubRoutine
case class A_Func(lbl: A_Label, instrs: List[A_Instr]) extends A_SubRoutine
case class A_DataFunc(lbl: A_InstrLabel, instrs: List[A_Instr], data: A_StoredStr) extends A_SubRoutine

/**
 * A_Instr, an instruction in the assembly IR.
 * Instructions are either arithmetic operations, bitwise operations, memory operations, or control flow operations.
 * @param opD the destination register for the operation
 * @param opS the source operand for the operation
 * @param opSize the size of the operand
 * @param condition the condition for the operation sent to the zero flag
 * @param label the label to be jumped to
 * @param op1 the first operand for the comparison
 * @param op2 the second operand for the comparison
 */
sealed trait A_Instr
case class A_Call(label: A_Label) extends A_Instr
case class A_Jmp(label: A_Label, condition: A_Cond) extends A_Instr
case class A_LabelStart(label: A_Label) extends A_Instr
case class A_Push(opS: A_Reg) extends A_Instr
case class A_Pop(opS: A_Reg) extends A_Instr
case class A_Cmp(op1: A_Reg, op2: A_Operand, opSize: A_OperandSize) extends A_Instr
case class A_Movzx(opD: A_Reg, opS: A_Reg, opSize1: A_OperandSize, opSize2: A_OperandSize) extends A_Instr
case class A_Lea(opD: A_Reg, opS: A_MemOffset) extends A_Instr
case class A_Set(opD: A_Reg, condition: A_Cond) extends A_Instr
case class A_Mov private(opD: A_Operand, opS: A_Operand, opSize: A_OperandSize) extends A_Instr

object A_Mov {
    def apply(opD: A_Reg, opS: A_Operand, opSize: A_OperandSize): A_Mov = new A_Mov(opD, opS, opSize)
    def apply(opD: A_Operand, opS: A_Reg, opSize: A_OperandSize): A_Mov = new A_Mov(opD, opS, opSize) 
    def apply(opD: A_Reg, opS: A_Reg, opSize: A_OperandSize): A_Mov = new A_Mov(opD, opS, opSize)
}

/**
 * A sealed trait representing an arithmetic operation in the assembly IR.
 * @param opD the destination register for the operation
 * @param opS the source operand for the operation
 * @param opSize the size of the operand
 */
sealed trait A_ArithmeticOp extends A_Instr
case class A_Add(opD: A_Reg, opS: A_Operand, opSize: A_OperandSize) extends A_ArithmeticOp 
case class A_Sub(opD: A_Reg, opS: A_Operand, opSize: A_OperandSize) extends A_ArithmeticOp
case class A_Div(opD: A_Reg, opS: A_Operand, opSize: A_OperandSize) extends A_ArithmeticOp
case class A_IMul(opD: A_Reg, opS: A_Operand, opSize: A_OperandSize) extends A_ArithmeticOp
case class A_IDiv(op: A_Reg, opSize: A_OperandSize) extends A_ArithmeticOp

/**
  * A sealed trait representing a bitwise operation in the assembly IR.
  * @param opD the destination register for the operation
  * @param opS the source operand for the operation
  * @param opSize the size of the operand
  */
sealed trait A_BitwiseOp extends A_Instr
case class A_And(opD: A_Reg, opS: A_Operand, opSize: A_OperandSize) extends A_BitwiseOp 
case class A_Xor(opD: A_Reg, opS: A_Operand, opSize: A_OperandSize) extends A_BitwiseOp 

/**
  * A_CDQ, Convert Doubleword to Quadword extends EAX into EAX:EDX
  */
case object A_CDQ extends A_Instr

/**
  * A_Ret, subroutine return instruction
  */
case object A_Ret extends A_Instr

/**
  * A_Cond, an enum representing all the conditions for a jump instruction
  */
enum A_Cond {
    case Eq
    case NEq
    case Gt
    case Lt
    case GEq
    case LEq
    case Overflow
    case NOverflow
    case Uncond
}
